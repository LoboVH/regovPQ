"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegisterRoutes = void 0;
/* tslint:disable */
/* eslint-disable */
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
const runtime_1 = require("@tsoa/runtime");
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
const AgentController_1 = require("./../controllers/agent/AgentController");
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
const BasicMessageController_1 = require("./../controllers/basic-messages/BasicMessageController");
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
const ConnectionController_1 = require("./../controllers/connections/ConnectionController");
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
const CredentialController_1 = require("./../controllers/credentials/CredentialController");
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
const CredentialDefinitionController_1 = require("./../controllers/credentials/CredentialDefinitionController");
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
const SchemaController_1 = require("./../controllers/credentials/SchemaController");
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
const DidController_1 = require("./../controllers/did/DidController");
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
const OutOfBandController_1 = require("./../controllers/outofband/OutOfBandController");
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
const ProofController_1 = require("./../controllers/proofs/ProofController");
const tsyringeTsoaIocContainer_1 = require("./../utils/tsyringeTsoaIocContainer");
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
const models = {
    "AgentInfo": {
        "dataType": "refObject",
        "properties": {
            "label": { "dataType": "string", "required": true },
            "endpoints": { "dataType": "array", "array": { "dataType": "string" }, "required": true },
            "isInitialized": { "dataType": "boolean", "required": true },
            "publicDid": { "dataType": "nestedObjectLiteral", "nestedProperties": { "verkey": { "dataType": "string", "required": true }, "did": { "dataType": "string", "required": true } } },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Record_string.unknown_": {
        "dataType": "refAlias",
        "type": { "dataType": "nestedObjectLiteral", "nestedProperties": {}, "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "BasicMessageRecord": {
        "dataType": "refAlias",
        "type": { "ref": "Record_string.unknown_", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "RecordId": {
        "dataType": "refAlias",
        "type": { "dataType": "string", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Record_content.string_": {
        "dataType": "refAlias",
        "type": { "dataType": "nestedObjectLiteral", "nestedProperties": { "content": { "dataType": "string" } }, "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "DidExchangeState": {
        "dataType": "refEnum",
        "enums": ["start", "invitation-sent", "invitation-received", "request-sent", "request-received", "response-sent", "response-received", "abandoned", "completed"],
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Record_string.any_": {
        "dataType": "refAlias",
        "type": { "dataType": "nestedObjectLiteral", "nestedProperties": {}, "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "CredentialState": {
        "dataType": "refEnum",
        "enums": ["proposal-sent", "proposal-received", "offer-sent", "offer-received", "declined", "request-sent", "request-received", "credential-issued", "credential-received", "done"],
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "ProtocolVersionType_CredentialServices_": {
        "dataType": "refAlias",
        "type": { "dataType": "string", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "AutoAcceptCredential": {
        "dataType": "refEnum",
        "enums": ["always", "contentApproved", "never"],
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "ProposeCredentialOptions": {
        "dataType": "refObject",
        "properties": {
            "protocolVersion": { "ref": "ProtocolVersionType_CredentialServices_", "required": true },
            "credentialFormats": { "dataType": "nestedObjectLiteral", "nestedProperties": { "indy": { "dataType": "nestedObjectLiteral", "nestedProperties": { "attributes": { "dataType": "array", "array": { "dataType": "nestedObjectLiteral", "nestedProperties": { "value": { "dataType": "string", "required": true }, "name": { "dataType": "string", "required": true } } }, "required": true }, "issuerDid": { "dataType": "string", "required": true }, "credentialDefinitionId": { "dataType": "string", "required": true }, "schemaVersion": { "dataType": "string", "required": true }, "schemaName": { "dataType": "string", "required": true }, "schemaId": { "dataType": "string", "required": true }, "schemaIssuerDid": { "dataType": "string", "required": true } }, "required": true } }, "required": true },
            "autoAcceptCredential": { "ref": "AutoAcceptCredential" },
            "comment": { "dataType": "string" },
            "connectionId": { "dataType": "string", "required": true },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "AcceptCredentialProposalOptions": {
        "dataType": "refObject",
        "properties": {
            "credentialFormats": { "dataType": "nestedObjectLiteral", "nestedProperties": { "indy": { "dataType": "nestedObjectLiteral", "nestedProperties": { "attributes": { "dataType": "array", "array": { "dataType": "nestedObjectLiteral", "nestedProperties": { "value": { "dataType": "string", "required": true }, "name": { "dataType": "string", "required": true } } }, "required": true }, "issuerDid": { "dataType": "string", "required": true }, "credentialDefinitionId": { "dataType": "string", "required": true }, "schemaVersion": { "dataType": "string", "required": true }, "schemaName": { "dataType": "string", "required": true }, "schemaId": { "dataType": "string", "required": true }, "schemaIssuerDid": { "dataType": "string", "required": true } }, "required": true } } },
            "autoAcceptCredential": { "ref": "AutoAcceptCredential" },
            "comment": { "dataType": "string" },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "CreateOfferOptions": {
        "dataType": "refObject",
        "properties": {
            "protocolVersion": { "ref": "ProtocolVersionType_CredentialServices_", "required": true },
            "credentialFormats": { "dataType": "nestedObjectLiteral", "nestedProperties": { "indy": { "dataType": "nestedObjectLiteral", "nestedProperties": { "attributes": { "dataType": "array", "array": { "dataType": "nestedObjectLiteral", "nestedProperties": { "value": { "dataType": "string", "required": true }, "name": { "dataType": "string", "required": true } } }, "required": true }, "credentialDefinitionId": { "dataType": "string", "required": true } }, "required": true } }, "required": true },
            "autoAcceptCredential": { "ref": "AutoAcceptCredential" },
            "comment": { "dataType": "string" },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "OfferCredentialOptions": {
        "dataType": "refObject",
        "properties": {
            "protocolVersion": { "ref": "ProtocolVersionType_CredentialServices_", "required": true },
            "credentialFormats": { "dataType": "nestedObjectLiteral", "nestedProperties": { "indy": { "dataType": "nestedObjectLiteral", "nestedProperties": { "attributes": { "dataType": "array", "array": { "dataType": "nestedObjectLiteral", "nestedProperties": { "value": { "dataType": "string", "required": true }, "name": { "dataType": "string", "required": true } } }, "required": true }, "credentialDefinitionId": { "dataType": "string", "required": true } }, "required": true } }, "required": true },
            "autoAcceptCredential": { "ref": "AutoAcceptCredential" },
            "comment": { "dataType": "string" },
            "connectionId": { "dataType": "string", "required": true },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "IndyAcceptOfferFormat": {
        "dataType": "refObject",
        "properties": {
            "holderDid": { "dataType": "string" },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "CredentialFormatPayload_CredentialFormats.acceptOffer_": {
        "dataType": "refAlias",
        "type": { "dataType": "nestedObjectLiteral", "nestedProperties": { "indy": { "ref": "IndyAcceptOfferFormat" } }, "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "AcceptCredentialOfferOptions": {
        "dataType": "refObject",
        "properties": {
            "credentialFormats": { "ref": "CredentialFormatPayload_CredentialFormats.acceptOffer_" },
            "autoAcceptCredential": { "ref": "AutoAcceptCredential" },
            "comment": { "dataType": "string" },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "CredentialFormatPayload_CredentialFormats.acceptRequest_": {
        "dataType": "refAlias",
        "type": { "dataType": "nestedObjectLiteral", "nestedProperties": { "indy": { "ref": "Record_string.any_" } }, "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "AcceptCredentialRequestOptions": {
        "dataType": "refObject",
        "properties": {
            "credentialFormats": { "ref": "CredentialFormatPayload_CredentialFormats.acceptRequest_" },
            "autoAcceptCredential": { "ref": "AutoAcceptCredential" },
            "comment": { "dataType": "string" },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "CredentialDefinitionId": {
        "dataType": "refAlias",
        "type": { "dataType": "string", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "SchemaId": {
        "dataType": "refAlias",
        "type": { "dataType": "string", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Version": {
        "dataType": "refAlias",
        "type": { "dataType": "string", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "DidResolutionMetadata": {
        "dataType": "refObject",
        "properties": {
            "contentType": { "dataType": "string" },
            "error": { "dataType": "union", "subSchemas": [{ "dataType": "enum", "enums": ["invalidDid"] }, { "dataType": "enum", "enums": ["notFound"] }, { "dataType": "enum", "enums": ["representationNotSupported"] }, { "dataType": "enum", "enums": ["unsupportedDidMethod"] }, { "dataType": "string" }] },
            "message": { "dataType": "string" },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "DidDocument": {
        "dataType": "refAlias",
        "type": { "ref": "Record_string.any_", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "DIDDocumentMetadata": {
        "dataType": "refObject",
        "properties": {
            "created": { "dataType": "string" },
            "updated": { "dataType": "string" },
            "deactivated": { "dataType": "boolean" },
            "versionId": { "dataType": "string" },
            "nextUpdate": { "dataType": "string" },
            "nextVersionId": { "dataType": "string" },
            "equivalentId": { "dataType": "string" },
            "canonicalId": { "dataType": "string" },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "DidDocumentMetadata": {
        "dataType": "refAlias",
        "type": { "ref": "DIDDocumentMetadata", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "DidResolutionResult": {
        "dataType": "refObject",
        "properties": {
            "didResolutionMetadata": { "ref": "DidResolutionMetadata", "required": true },
            "didDocument": { "dataType": "union", "subSchemas": [{ "ref": "DidDocument" }, { "dataType": "enum", "enums": [null] }], "required": true },
            "didDocumentMetadata": { "ref": "DidDocumentMetadata", "required": true },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Did": {
        "dataType": "refAlias",
        "type": { "dataType": "string", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "HandshakeProtocol": {
        "dataType": "refEnum",
        "enums": ["https://didcomm.org/connections/1.0", "https://didcomm.org/didexchange/1.0"],
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Pick_CreateOutOfBandInvitationConfig.Exclude_keyofCreateOutOfBandInvitationConfig.routing-or-appendedAttachments-or-messages__": {
        "dataType": "refAlias",
        "type": { "dataType": "nestedObjectLiteral", "nestedProperties": { "alias": { "dataType": "string" }, "label": { "dataType": "string" }, "imageUrl": { "dataType": "string" }, "goalCode": { "dataType": "string" }, "goal": { "dataType": "string" }, "handshake": { "dataType": "boolean" }, "handshakeProtocols": { "dataType": "array", "array": { "dataType": "refEnum", "ref": "HandshakeProtocol" } }, "multiUseInvitation": { "dataType": "boolean" }, "autoAcceptConnection": { "dataType": "boolean" } }, "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Omit_CreateOutOfBandInvitationConfig.routing-or-appendedAttachments-or-messages_": {
        "dataType": "refAlias",
        "type": { "ref": "Pick_CreateOutOfBandInvitationConfig.Exclude_keyofCreateOutOfBandInvitationConfig.routing-or-appendedAttachments-or-messages__", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Pick_CreateLegacyInvitationConfig.Exclude_keyofCreateLegacyInvitationConfig.routing__": {
        "dataType": "refAlias",
        "type": { "dataType": "nestedObjectLiteral", "nestedProperties": { "alias": { "dataType": "string" }, "label": { "dataType": "string" }, "imageUrl": { "dataType": "string" }, "multiUseInvitation": { "dataType": "boolean" }, "autoAcceptConnection": { "dataType": "boolean" } }, "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Omit_CreateLegacyInvitationConfig.routing_": {
        "dataType": "refAlias",
        "type": { "ref": "Pick_CreateLegacyInvitationConfig.Exclude_keyofCreateLegacyInvitationConfig.routing__", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "AgentMessageType": {
        "dataType": "refObject",
        "properties": {
            "@id": { "dataType": "string", "required": true },
            "@type": { "dataType": "string", "required": true },
        },
        "additionalProperties": { "dataType": "any" },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "OutOfBandDidCommService": {
        "dataType": "refObject",
        "properties": {
            "id": { "dataType": "string", "required": true },
            "serviceEndpoint": { "dataType": "string", "required": true },
            "type": { "dataType": "string", "required": true },
            "recipientKeys": { "dataType": "array", "array": { "dataType": "string" }, "required": true },
            "routingKeys": { "dataType": "array", "array": { "dataType": "string" } },
            "accept": { "dataType": "array", "array": { "dataType": "string" } },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Pick_OutOfBandInvitationSchema.Exclude_keyofOutOfBandInvitationSchema.appendedAttachments__": {
        "dataType": "refAlias",
        "type": { "dataType": "nestedObjectLiteral", "nestedProperties": { "label": { "dataType": "string", "required": true }, "imageUrl": { "dataType": "string" }, "goalCode": { "dataType": "string" }, "goal": { "dataType": "string" }, "@id": { "dataType": "string" }, "@type": { "dataType": "string", "required": true }, "accept": { "dataType": "array", "array": { "dataType": "string" } }, "handshake_protocols": { "dataType": "array", "array": { "dataType": "refEnum", "ref": "HandshakeProtocol" } }, "services": { "dataType": "array", "array": { "dataType": "union", "subSchemas": [{ "ref": "OutOfBandDidCommService" }, { "dataType": "string" }] }, "required": true } }, "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Omit_OutOfBandInvitationSchema.appendedAttachments_": {
        "dataType": "refAlias",
        "type": { "ref": "Pick_OutOfBandInvitationSchema.Exclude_keyofOutOfBandInvitationSchema.appendedAttachments__", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Pick_ReceiveOutOfBandInvitationConfig.Exclude_keyofReceiveOutOfBandInvitationConfig.routing__": {
        "dataType": "refAlias",
        "type": { "dataType": "nestedObjectLiteral", "nestedProperties": { "alias": { "dataType": "string" }, "label": { "dataType": "string" }, "imageUrl": { "dataType": "string" }, "autoAcceptConnection": { "dataType": "boolean" }, "autoAcceptInvitation": { "dataType": "boolean" }, "reuseConnection": { "dataType": "boolean" } }, "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Omit_ReceiveOutOfBandInvitationConfig.routing_": {
        "dataType": "refAlias",
        "type": { "ref": "Pick_ReceiveOutOfBandInvitationConfig.Exclude_keyofReceiveOutOfBandInvitationConfig.routing__", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "ReceiveInvitationProps": {
        "dataType": "refObject",
        "properties": {
            "alias": { "dataType": "string" },
            "label": { "dataType": "string" },
            "imageUrl": { "dataType": "string" },
            "autoAcceptConnection": { "dataType": "boolean" },
            "autoAcceptInvitation": { "dataType": "boolean" },
            "reuseConnection": { "dataType": "boolean" },
            "invitation": { "ref": "Omit_OutOfBandInvitationSchema.appendedAttachments_", "required": true },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "ReceiveInvitationByUrlProps": {
        "dataType": "refObject",
        "properties": {
            "alias": { "dataType": "string" },
            "label": { "dataType": "string" },
            "imageUrl": { "dataType": "string" },
            "autoAcceptConnection": { "dataType": "boolean" },
            "autoAcceptInvitation": { "dataType": "boolean" },
            "reuseConnection": { "dataType": "boolean" },
            "invitationUrl": { "dataType": "string", "required": true },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "AcceptInvitationConfig": {
        "dataType": "refObject",
        "properties": {
            "autoAcceptConnection": { "dataType": "boolean" },
            "reuseConnection": { "dataType": "boolean" },
            "label": { "dataType": "string" },
            "alias": { "dataType": "string" },
            "imageUrl": { "dataType": "string" },
            "mediatorId": { "dataType": "string" },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "PresentationPreviewAttributeOptions": {
        "dataType": "refObject",
        "properties": {
            "name": { "dataType": "string", "required": true },
            "credentialDefinitionId": { "dataType": "string" },
            "mimeType": { "dataType": "string" },
            "value": { "dataType": "string" },
            "referent": { "dataType": "string" },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "PredicateType": {
        "dataType": "refEnum",
        "enums": ["<", "<=", ">", ">="],
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "PresentationPreviewPredicateOptions": {
        "dataType": "refObject",
        "properties": {
            "name": { "dataType": "string", "required": true },
            "credentialDefinitionId": { "dataType": "string", "required": true },
            "predicate": { "ref": "PredicateType", "required": true },
            "threshold": { "dataType": "double", "required": true },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "AutoAcceptProof": {
        "dataType": "refEnum",
        "enums": ["always", "contentApproved", "never"],
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "RequestProofProposalOptions": {
        "dataType": "refObject",
        "properties": {
            "connectionId": { "dataType": "string", "required": true },
            "attributes": { "dataType": "array", "array": { "dataType": "refObject", "ref": "PresentationPreviewAttributeOptions" }, "required": true },
            "predicates": { "dataType": "array", "array": { "dataType": "refObject", "ref": "PresentationPreviewPredicateOptions" }, "required": true },
            "comment": { "dataType": "string" },
            "autoAcceptProof": { "ref": "AutoAcceptProof" },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "ProofRecord": {
        "dataType": "refAlias",
        "type": { "ref": "Record_string.unknown_", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "IndyRevocationInterval": {
        "dataType": "refObject",
        "properties": {
            "from": { "dataType": "double" },
            "to": { "dataType": "double" },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "AttributeValue": {
        "dataType": "refObject",
        "properties": {
            "name": { "dataType": "string", "required": true },
            "value": { "dataType": "string", "required": true },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "AttributeFilter": {
        "dataType": "refObject",
        "properties": {
            "schemaId": { "dataType": "string" },
            "schemaIssuerDid": { "dataType": "string" },
            "schemaName": { "dataType": "string" },
            "schemaVersion": { "dataType": "string" },
            "issuerDid": { "dataType": "string" },
            "credentialDefinitionId": { "dataType": "string" },
            "attributeValue": { "ref": "AttributeValue" },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "ProofAttributeInfo": {
        "dataType": "refObject",
        "properties": {
            "name": { "dataType": "string" },
            "names": { "dataType": "array", "array": { "dataType": "string" } },
            "nonRevoked": { "ref": "IndyRevocationInterval" },
            "restrictions": { "dataType": "array", "array": { "dataType": "refObject", "ref": "AttributeFilter" } },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "ProofPredicateInfo": {
        "dataType": "refObject",
        "properties": {
            "name": { "dataType": "string", "required": true },
            "predicateType": { "ref": "PredicateType", "required": true },
            "predicateValue": { "dataType": "double", "required": true },
            "nonRevoked": { "ref": "IndyRevocationInterval" },
            "restrictions": { "dataType": "array", "array": { "dataType": "refObject", "ref": "AttributeFilter" } },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Pick_RequestProofOptions.Exclude_keyofRequestProofOptions.connectionId__": {
        "dataType": "refAlias",
        "type": { "dataType": "nestedObjectLiteral", "nestedProperties": { "comment": { "dataType": "string" }, "autoAcceptProof": { "ref": "AutoAcceptProof" }, "proofRequestOptions": { "dataType": "nestedObjectLiteral", "nestedProperties": { "requestedPredicates": { "dataType": "nestedObjectLiteral", "nestedProperties": {}, "additionalProperties": { "ref": "ProofPredicateInfo" } }, "requestedAttributes": { "dataType": "nestedObjectLiteral", "nestedProperties": {}, "additionalProperties": { "ref": "ProofAttributeInfo" } }, "version": { "dataType": "string", "required": true }, "name": { "dataType": "string", "required": true } }, "required": true }, "parentThreadId": { "dataType": "string" } }, "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "Omit_RequestProofOptions.connectionId_": {
        "dataType": "refAlias",
        "type": { "ref": "Pick_RequestProofOptions.Exclude_keyofRequestProofOptions.connectionId__", "validators": {} },
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    "RequestProofOptions": {
        "dataType": "refObject",
        "properties": {
            "comment": { "dataType": "string" },
            "autoAcceptProof": { "ref": "AutoAcceptProof" },
            "parentThreadId": { "dataType": "string" },
            "connectionId": { "dataType": "string", "required": true },
            "proofRequestOptions": { "dataType": "nestedObjectLiteral", "nestedProperties": { "requestedPredicates": { "dataType": "nestedObjectLiteral", "nestedProperties": {}, "additionalProperties": { "ref": "ProofPredicateInfo" } }, "requestedAttributes": { "dataType": "nestedObjectLiteral", "nestedProperties": {}, "additionalProperties": { "ref": "ProofAttributeInfo" } }, "version": { "dataType": "string", "required": true }, "name": { "dataType": "string", "required": true } }, "required": true },
        },
        "additionalProperties": false,
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
};
const validationService = new runtime_1.ValidationService(models);
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
function RegisterRoutes(app) {
    // ###########################################################################################################
    //  NOTE: If you do not see routes for all of your controllers in this file, then you might not have informed tsoa of where to look
    //      Please look into the "controllerPathGlobs" config option described in the readme: https://github.com/lukeautry/tsoa
    // ###########################################################################################################
    app.get('/agent', ...((0, runtime_1.fetchMiddlewares)(AgentController_1.AgentController)), ...((0, runtime_1.fetchMiddlewares)(AgentController_1.AgentController.prototype.getAgentInfo)), async function AgentController_getAgentInfo(request, response, next) {
        const args = {};
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(AgentController_1.AgentController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.getAgentInfo.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.get('/basic-messages/:connectionId', ...((0, runtime_1.fetchMiddlewares)(BasicMessageController_1.BasicMessageController)), ...((0, runtime_1.fetchMiddlewares)(BasicMessageController_1.BasicMessageController.prototype.getBasicMessages)), async function BasicMessageController_getBasicMessages(request, response, next) {
        const args = {
            connectionId: { "in": "path", "name": "connectionId", "required": true, "ref": "RecordId" },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(BasicMessageController_1.BasicMessageController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.getBasicMessages.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/basic-messages/:connectionId', ...((0, runtime_1.fetchMiddlewares)(BasicMessageController_1.BasicMessageController)), ...((0, runtime_1.fetchMiddlewares)(BasicMessageController_1.BasicMessageController.prototype.sendMessage)), async function BasicMessageController_sendMessage(request, response, next) {
        const args = {
            connectionId: { "in": "path", "name": "connectionId", "required": true, "ref": "RecordId" },
            request: { "in": "body", "name": "request", "required": true, "ref": "Record_content.string_" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(BasicMessageController_1.BasicMessageController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.sendMessage.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.get('/connections', ...((0, runtime_1.fetchMiddlewares)(ConnectionController_1.ConnectionController)), ...((0, runtime_1.fetchMiddlewares)(ConnectionController_1.ConnectionController.prototype.getAllConnections)), async function ConnectionController_getAllConnections(request, response, next) {
        const args = {
            outOfBandId: { "in": "query", "name": "outOfBandId", "dataType": "string" },
            alias: { "in": "query", "name": "alias", "dataType": "string" },
            state: { "in": "query", "name": "state", "ref": "DidExchangeState" },
            myDid: { "in": "query", "name": "myDid", "dataType": "string" },
            theirDid: { "in": "query", "name": "theirDid", "dataType": "string" },
            theirLabel: { "in": "query", "name": "theirLabel", "dataType": "string" },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ConnectionController_1.ConnectionController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.getAllConnections.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.get('/connections/:connectionId', ...((0, runtime_1.fetchMiddlewares)(ConnectionController_1.ConnectionController)), ...((0, runtime_1.fetchMiddlewares)(ConnectionController_1.ConnectionController.prototype.getConnectionById)), async function ConnectionController_getConnectionById(request, response, next) {
        const args = {
            connectionId: { "in": "path", "name": "connectionId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ConnectionController_1.ConnectionController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.getConnectionById.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.delete('/connections/:connectionId', ...((0, runtime_1.fetchMiddlewares)(ConnectionController_1.ConnectionController)), ...((0, runtime_1.fetchMiddlewares)(ConnectionController_1.ConnectionController.prototype.deleteConnection)), async function ConnectionController_deleteConnection(request, response, next) {
        const args = {
            connectionId: { "in": "path", "name": "connectionId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ConnectionController_1.ConnectionController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.deleteConnection.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/connections/:connectionId/accept-request', ...((0, runtime_1.fetchMiddlewares)(ConnectionController_1.ConnectionController)), ...((0, runtime_1.fetchMiddlewares)(ConnectionController_1.ConnectionController.prototype.acceptRequest)), async function ConnectionController_acceptRequest(request, response, next) {
        const args = {
            connectionId: { "in": "path", "name": "connectionId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ConnectionController_1.ConnectionController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.acceptRequest.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/connections/:connectionId/accept-response', ...((0, runtime_1.fetchMiddlewares)(ConnectionController_1.ConnectionController)), ...((0, runtime_1.fetchMiddlewares)(ConnectionController_1.ConnectionController.prototype.acceptResponse)), async function ConnectionController_acceptResponse(request, response, next) {
        const args = {
            connectionId: { "in": "path", "name": "connectionId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ConnectionController_1.ConnectionController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.acceptResponse.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.get('/credentials', ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController)), ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController.prototype.getAllCredentials)), async function CredentialController_getAllCredentials(request, response, next) {
        const args = {
            threadId: { "in": "query", "name": "threadId", "dataType": "string" },
            connectionId: { "in": "query", "name": "connectionId", "dataType": "string" },
            state: { "in": "query", "name": "state", "ref": "CredentialState" },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(CredentialController_1.CredentialController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.getAllCredentials.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.get('/credentials/:credentialRecordId', ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController)), ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController.prototype.getCredentialById)), async function CredentialController_getCredentialById(request, response, next) {
        const args = {
            credentialRecordId: { "in": "path", "name": "credentialRecordId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(CredentialController_1.CredentialController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.getCredentialById.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.delete('/credentials/:credentialRecordId', ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController)), ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController.prototype.deleteCredential)), async function CredentialController_deleteCredential(request, response, next) {
        const args = {
            credentialRecordId: { "in": "path", "name": "credentialRecordId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(CredentialController_1.CredentialController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.deleteCredential.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/credentials/propose-credential', ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController)), ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController.prototype.proposeCredential)), async function CredentialController_proposeCredential(request, response, next) {
        const args = {
            options: { "in": "body", "name": "options", "required": true, "ref": "ProposeCredentialOptions" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(CredentialController_1.CredentialController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.proposeCredential.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/credentials/:credentialRecordId/accept-proposal', ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController)), ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController.prototype.acceptProposal)), async function CredentialController_acceptProposal(request, response, next) {
        const args = {
            credentialRecordId: { "in": "path", "name": "credentialRecordId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
            options: { "in": "body", "name": "options", "ref": "AcceptCredentialProposalOptions" },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(CredentialController_1.CredentialController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.acceptProposal.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/credentials/create-offer', ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController)), ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController.prototype.createOffer)), async function CredentialController_createOffer(request, response, next) {
        const args = {
            options: { "in": "body", "name": "options", "required": true, "ref": "CreateOfferOptions" },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(CredentialController_1.CredentialController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.createOffer.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/credentials/offer-credential', ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController)), ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController.prototype.offerCredential)), async function CredentialController_offerCredential(request, response, next) {
        const args = {
            options: { "in": "body", "name": "options", "required": true, "ref": "OfferCredentialOptions" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(CredentialController_1.CredentialController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.offerCredential.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/credentials/:credentialRecordId/accept-offer', ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController)), ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController.prototype.acceptOffer)), async function CredentialController_acceptOffer(request, response, next) {
        const args = {
            credentialRecordId: { "in": "path", "name": "credentialRecordId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
            options: { "in": "body", "name": "options", "ref": "AcceptCredentialOfferOptions" },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(CredentialController_1.CredentialController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.acceptOffer.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/credentials/:credentialRecordId/accept-request', ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController)), ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController.prototype.acceptRequest)), async function CredentialController_acceptRequest(request, response, next) {
        const args = {
            credentialRecordId: { "in": "path", "name": "credentialRecordId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
            options: { "in": "body", "name": "options", "ref": "AcceptCredentialRequestOptions" },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(CredentialController_1.CredentialController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.acceptRequest.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/credentials/:credentialRecordId/accept-credential', ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController)), ...((0, runtime_1.fetchMiddlewares)(CredentialController_1.CredentialController.prototype.acceptCredential)), async function CredentialController_acceptCredential(request, response, next) {
        const args = {
            credentialRecordId: { "in": "path", "name": "credentialRecordId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(CredentialController_1.CredentialController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.acceptCredential.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.get('/credential-definitions/:credentialDefinitionId', ...((0, runtime_1.fetchMiddlewares)(CredentialDefinitionController_1.CredentialDefinitionController)), ...((0, runtime_1.fetchMiddlewares)(CredentialDefinitionController_1.CredentialDefinitionController.prototype.getCredentialDefinitionById)), async function CredentialDefinitionController_getCredentialDefinitionById(request, response, next) {
        const args = {
            credentialDefinitionId: { "in": "path", "name": "credentialDefinitionId", "required": true, "ref": "CredentialDefinitionId" },
            badRequestError: { "in": "res", "name": "400", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(CredentialDefinitionController_1.CredentialDefinitionController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.getCredentialDefinitionById.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/credential-definitions', ...((0, runtime_1.fetchMiddlewares)(CredentialDefinitionController_1.CredentialDefinitionController)), ...((0, runtime_1.fetchMiddlewares)(CredentialDefinitionController_1.CredentialDefinitionController.prototype.createCredentialDefinition)), async function CredentialDefinitionController_createCredentialDefinition(request, response, next) {
        const args = {
            credentialDefinitionRequest: { "in": "body", "name": "credentialDefinitionRequest", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "tag": { "dataType": "string", "required": true }, "supportRevocation": { "dataType": "boolean", "required": true }, "schemaId": { "ref": "SchemaId", "required": true } } },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(CredentialDefinitionController_1.CredentialDefinitionController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.createCredentialDefinition.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.get('/schemas/:schemaId', ...((0, runtime_1.fetchMiddlewares)(SchemaController_1.SchemaController)), ...((0, runtime_1.fetchMiddlewares)(SchemaController_1.SchemaController.prototype.getSchemaById)), async function SchemaController_getSchemaById(request, response, next) {
        const args = {
            schemaId: { "in": "path", "name": "schemaId", "required": true, "ref": "SchemaId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            forbiddenError: { "in": "res", "name": "403", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            badRequestError: { "in": "res", "name": "400", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(SchemaController_1.SchemaController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.getSchemaById.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/schemas', ...((0, runtime_1.fetchMiddlewares)(SchemaController_1.SchemaController)), ...((0, runtime_1.fetchMiddlewares)(SchemaController_1.SchemaController.prototype.createSchema)), async function SchemaController_createSchema(request, response, next) {
        const args = {
            schema: { "in": "body", "name": "schema", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "attributes": { "dataType": "array", "array": { "dataType": "string" }, "required": true }, "version": { "ref": "Version", "required": true }, "name": { "dataType": "string", "required": true } } },
            forbiddenError: { "in": "res", "name": "400", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(SchemaController_1.SchemaController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.createSchema.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.get('/dids/:did', ...((0, runtime_1.fetchMiddlewares)(DidController_1.DidController)), ...((0, runtime_1.fetchMiddlewares)(DidController_1.DidController.prototype.getDidRecordByDid)), async function DidController_getDidRecordByDid(request, response, next) {
        const args = {
            did: { "in": "path", "name": "did", "required": true, "ref": "Did" },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(DidController_1.DidController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.getDidRecordByDid.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.get('/oob', ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController)), ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController.prototype.getAllOutOfBandRecords)), async function OutOfBandController_getAllOutOfBandRecords(request, response, next) {
        const args = {
            invitationId: { "in": "query", "name": "invitationId", "ref": "RecordId" },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(OutOfBandController_1.OutOfBandController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.getAllOutOfBandRecords.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.get('/oob/:outOfBandId', ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController)), ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController.prototype.getOutOfBandRecordById)), async function OutOfBandController_getOutOfBandRecordById(request, response, next) {
        const args = {
            outOfBandId: { "in": "path", "name": "outOfBandId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(OutOfBandController_1.OutOfBandController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.getOutOfBandRecordById.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/oob/create-invitation', ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController)), ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController.prototype.createInvitation)), async function OutOfBandController_createInvitation(request, response, next) {
        const args = {
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
            config: { "in": "body", "name": "config", "ref": "Omit_CreateOutOfBandInvitationConfig.routing-or-appendedAttachments-or-messages_" },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(OutOfBandController_1.OutOfBandController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.createInvitation.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/oob/create-legacy-invitation', ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController)), ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController.prototype.createLegacyInvitation)), async function OutOfBandController_createLegacyInvitation(request, response, next) {
        const args = {
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
            config: { "in": "body", "name": "config", "ref": "Omit_CreateLegacyInvitationConfig.routing_" },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(OutOfBandController_1.OutOfBandController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.createLegacyInvitation.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/oob/create-legacy-connectionless-invitation', ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController)), ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController.prototype.createLegacyConnectionlessInvitation)), async function OutOfBandController_createLegacyConnectionlessInvitation(request, response, next) {
        const args = {
            config: { "in": "body", "name": "config", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "domain": { "dataType": "string", "required": true }, "message": { "ref": "AgentMessageType", "required": true }, "recordId": { "dataType": "string", "required": true } } },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(OutOfBandController_1.OutOfBandController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.createLegacyConnectionlessInvitation.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/oob/receive-invitation', ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController)), ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController.prototype.receiveInvitation)), async function OutOfBandController_receiveInvitation(request, response, next) {
        const args = {
            invitationRequest: { "in": "body", "name": "invitationRequest", "required": true, "ref": "ReceiveInvitationProps" },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(OutOfBandController_1.OutOfBandController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.receiveInvitation.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/oob/receive-invitation-url', ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController)), ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController.prototype.receiveInvitationFromUrl)), async function OutOfBandController_receiveInvitationFromUrl(request, response, next) {
        const args = {
            invitationRequest: { "in": "body", "name": "invitationRequest", "required": true, "ref": "ReceiveInvitationByUrlProps" },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(OutOfBandController_1.OutOfBandController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.receiveInvitationFromUrl.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/oob/:outOfBandId/accept-invitation', ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController)), ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController.prototype.acceptInvitation)), async function OutOfBandController_acceptInvitation(request, response, next) {
        const args = {
            outOfBandId: { "in": "path", "name": "outOfBandId", "required": true, "ref": "RecordId" },
            acceptInvitationConfig: { "in": "body", "name": "acceptInvitationConfig", "required": true, "ref": "AcceptInvitationConfig" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(OutOfBandController_1.OutOfBandController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.acceptInvitation.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.delete('/oob/:outOfBandId', ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController)), ...((0, runtime_1.fetchMiddlewares)(OutOfBandController_1.OutOfBandController.prototype.deleteOutOfBandRecord)), async function OutOfBandController_deleteOutOfBandRecord(request, response, next) {
        const args = {
            outOfBandId: { "in": "path", "name": "outOfBandId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(OutOfBandController_1.OutOfBandController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.deleteOutOfBandRecord.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.get('/proofs', ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController)), ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController.prototype.getAllProofs)), async function ProofController_getAllProofs(request, response, next) {
        const args = {
            threadId: { "in": "query", "name": "threadId", "dataType": "string" },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ProofController_1.ProofController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.getAllProofs.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.get('/proofs/:proofRecordId', ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController)), ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController.prototype.getProofById)), async function ProofController_getProofById(request, response, next) {
        const args = {
            proofRecordId: { "in": "path", "name": "proofRecordId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ProofController_1.ProofController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.getProofById.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.delete('/proofs/:proofRecordId', ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController)), ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController.prototype.deleteProof)), async function ProofController_deleteProof(request, response, next) {
        const args = {
            proofRecordId: { "in": "path", "name": "proofRecordId", "required": true, "ref": "RecordId" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ProofController_1.ProofController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.deleteProof.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/proofs/propose-proof', ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController)), ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController.prototype.proposeProof)), async function ProofController_proposeProof(request, response, next) {
        const args = {
            proposal: { "in": "body", "name": "proposal", "required": true, "ref": "RequestProofProposalOptions" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ProofController_1.ProofController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.proposeProof.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/proofs/:proofRecordId/accept-proposal', ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController)), ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController.prototype.acceptProposal)), async function ProofController_acceptProposal(request, response, next) {
        const args = {
            proofRecordId: { "in": "path", "name": "proofRecordId", "required": true, "dataType": "string" },
            proposal: { "in": "body", "name": "proposal", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "comment": { "dataType": "string" }, "request": { "dataType": "nestedObjectLiteral", "nestedProperties": { "nonce": { "dataType": "string" }, "version": { "dataType": "string" }, "name": { "dataType": "string" } }, "required": true } } },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ProofController_1.ProofController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.acceptProposal.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/proofs/request-outofband-proof', ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController)), ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController.prototype.requestProofOutOfBand)), async function ProofController_requestProofOutOfBand(request, response, next) {
        const args = {
            request: { "in": "body", "name": "request", "required": true, "ref": "Omit_RequestProofOptions.connectionId_" },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ProofController_1.ProofController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.requestProofOutOfBand.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/proofs/request-proof', ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController)), ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController.prototype.requestProof)), async function ProofController_requestProof(request, response, next) {
        const args = {
            request: { "in": "body", "name": "request", "required": true, "ref": "RequestProofOptions" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ProofController_1.ProofController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.requestProof.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/proofs/:proofRecordId/accept-request', ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController)), ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController.prototype.acceptRequest)), async function ProofController_acceptRequest(request, response, next) {
        const args = {
            proofRecordId: { "in": "path", "name": "proofRecordId", "required": true, "dataType": "string" },
            request: { "in": "body", "name": "request", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "comment": { "dataType": "string" }, "filterByNonRevocationRequirements": { "dataType": "boolean" }, "filterByPresentationPreview": { "dataType": "boolean" } } },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ProofController_1.ProofController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.acceptRequest.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    app.post('/proofs/:proofRecordId/accept-presentation', ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController)), ...((0, runtime_1.fetchMiddlewares)(ProofController_1.ProofController.prototype.acceptPresentation)), async function ProofController_acceptPresentation(request, response, next) {
        const args = {
            proofRecordId: { "in": "path", "name": "proofRecordId", "required": true, "dataType": "string" },
            notFoundError: { "in": "res", "name": "404", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "reason": { "dataType": "string", "required": true } } },
            internalServerError: { "in": "res", "name": "500", "required": true, "dataType": "nestedObjectLiteral", "nestedProperties": { "message": { "dataType": "string", "required": true } } },
        };
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        let validatedArgs = [];
        try {
            validatedArgs = getValidatedArgs(args, request, response);
            const container = typeof tsyringeTsoaIocContainer_1.iocContainer === 'function' ? tsyringeTsoaIocContainer_1.iocContainer(request) : tsyringeTsoaIocContainer_1.iocContainer;
            const controller = await container.get(ProofController_1.ProofController);
            if (typeof controller['setStatus'] === 'function') {
                controller.setStatus(undefined);
            }
            const promise = controller.acceptPresentation.apply(controller, validatedArgs);
            promiseHandler(controller, promise, response, undefined, next);
        }
        catch (err) {
            return next(err);
        }
    });
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    function isController(object) {
        return 'getHeaders' in object && 'getStatus' in object && 'setStatus' in object;
    }
    function promiseHandler(controllerObj, promise, response, successStatus, next) {
        return Promise.resolve(promise)
            .then((data) => {
            let statusCode = successStatus;
            let headers;
            if (isController(controllerObj)) {
                headers = controllerObj.getHeaders();
                statusCode = controllerObj.getStatus() || statusCode;
            }
            // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
            returnHandler(response, statusCode, data, headers);
        })
            .catch((error) => next(error));
    }
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    function returnHandler(response, statusCode, data, headers = {}) {
        if (response.headersSent) {
            return;
        }
        Object.keys(headers).forEach((name) => {
            response.set(name, headers[name]);
        });
        if (data && typeof data.pipe === 'function' && data.readable && typeof data._read === 'function') {
            data.pipe(response);
        }
        else if (data !== null && data !== undefined) {
            response.status(statusCode || 200).json(data);
        }
        else {
            response.status(statusCode || 204).end();
        }
    }
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    function responder(response) {
        return function (status, data, headers) {
            returnHandler(response, status, data, headers);
        };
    }
    ;
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    function getValidatedArgs(args, request, response) {
        const fieldErrors = {};
        const values = Object.keys(args).map((key) => {
            const name = args[key].name;
            switch (args[key].in) {
                case 'request':
                    return request;
                case 'query':
                    return validationService.ValidateParam(args[key], request.query[name], name, fieldErrors, undefined, { "noImplicitAdditionalProperties": "throw-on-extras" });
                case 'path':
                    return validationService.ValidateParam(args[key], request.params[name], name, fieldErrors, undefined, { "noImplicitAdditionalProperties": "throw-on-extras" });
                case 'header':
                    return validationService.ValidateParam(args[key], request.header(name), name, fieldErrors, undefined, { "noImplicitAdditionalProperties": "throw-on-extras" });
                case 'body':
                    return validationService.ValidateParam(args[key], request.body, name, fieldErrors, undefined, { "noImplicitAdditionalProperties": "throw-on-extras" });
                case 'body-prop':
                    return validationService.ValidateParam(args[key], request.body[name], name, fieldErrors, 'body.', { "noImplicitAdditionalProperties": "throw-on-extras" });
                case 'formData':
                    if (args[key].dataType === 'file') {
                        return validationService.ValidateParam(args[key], request.file, name, fieldErrors, undefined, { "noImplicitAdditionalProperties": "throw-on-extras" });
                    }
                    else if (args[key].dataType === 'array' && args[key].array.dataType === 'file') {
                        return validationService.ValidateParam(args[key], request.files, name, fieldErrors, undefined, { "noImplicitAdditionalProperties": "throw-on-extras" });
                    }
                    else {
                        return validationService.ValidateParam(args[key], request.body[name], name, fieldErrors, undefined, { "noImplicitAdditionalProperties": "throw-on-extras" });
                    }
                case 'res':
                    return responder(response);
            }
        });
        if (Object.keys(fieldErrors).length > 0) {
            throw new runtime_1.ValidateError(fieldErrors, '');
        }
        return values;
    }
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
}
exports.RegisterRoutes = RegisterRoutes;
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
//# sourceMappingURL=routes.js.map